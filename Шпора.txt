Вёрстка 
	*{padding:0; margin:0;}// убирает отступы по умолчанию во всех броузерах
	img{border:none;}//убирает рамки картинок (особенно IE)
	body{font-family:Arial; line-height:1.3;}// задаёт межстрочный интервал
	<link rel="stylesheet" type="text/css" href="style.css" />;// подключение стИлей CSS
	margin:0 auto;// центрирует div!!!
	overflow:hidden; - упорядочивает "выбитые" float блоки, разм. внутри
	http://www.colorzilla.com/gradient-editor/ - сервис построения градиентов инструментами CSS3
	float применённый для li выстраивает их в строку как display:inline
	display:block - приводит ссылки в меню к блочному типу и тогда работают паддинги
	если не "бьёт" высота блока (например иконки) - body{line-height:1.3;}//line-height:0 - высота строки
	.articles-head img{vertical-align:middle;}// центрует изображение в span
	.articles:last-child{border:none;}//псевдокласс, указатель на последний элемент, убирает из него border;
	.pager {margin:0 auto; display:table;//если div со ссылками в пагинаторе не центрируется - задать display:table
	float:left //в пагинаторе ко всем ссылкам применять обязательно, он переводит из строчного в блочный формат	
	text-transform:uppercase;// Если нужны ТОЛЬКО заглавные буквы, например в заголовке	
	background:rgba(0,0,0,0.6) - чёрный фон с прозрачностью


	



SQLite

$db = new SQLite3('test.db'); - создание экземпляра класса SQLine3? test.db - имя базы данных.
$result = $db->exec($sql) - безответый SQL запрос посылается EXECом ELECT, CREATE, DELETE (возвращает true или false)
$db->LastErorMsg() - описание ошибки в SQL запросе
	Фильтрация строк :
	function clearSTR($data){
		$data = strip_tags(trim($data));	
		return $this->_db->escapeString($data);}
	Фильтрация цифр :
		function clearInt($data){
		return $data = int abs(int($data));}
$result = querySingle($sql, true); - позволяет вытащить одну запись, или одну колонку (по умолчанию возвр.
		одна коронка = либо её значение, либо NULL
		<true> - возвращается одна запись массив или пустой массив
$result = $db->quary($sql) - возвращает массив???
$row = $result->fetchArray(); - выборка
	можно передать константы (по умолчанию SQLite3_BOTH - возвр. удвоенный массив, SQLite3_NUM - нумерованный массив
	SQLITE3_ASSOC - возврат ассоциативного массива)
	
запрос на выборку (SELECT "msgs.id as id" составное имя, так как есть 2 таблицы с одинаковым полем id)	
	function getNews(){
			$sql ="SELECT msgs.id as id, title, msgs.category as category, description, source, datetime FROM msgs, category WHERE category.id = msgs.category ORDER BY msgs.id DESC";
			$res = $this->_db->query($sql)or die ($this->_db->lastErrorMsg());
			return $this->db2Arr($res);	
	protected function db2Arr($data ){
		$arr = array();
			while ($row = $data->fetchArray(SQLITE3_ASSOC)){
			$arr[] = $row;
			}		
		return $arr;
		}
count ($arr); - возвращает кол-во элементов массива
$source = nl2br ($item['source']); - функция nl2br сохраняет переносы и переводы строк
$dt = date('d-m-Y H:i:s'); - пропустив поле таблицы DATETIME получим дату и время добавления	 
	
	SqLite - расширение для PHP, бибилиотека, написанная на языке С, служащая для работы с бд SQL. Данные хранятся в текстовом файле в бинарном виде и просто так его нельзя редактировать 
- с php 5.3. нет процедурного интерфейса
- 2 типа данных : integer и text. Если не уточнять тип - он всё воспринимает как строку
- 2 типа автоинкремента : 
	= INTEGER PRIMARY KEY AUTOINCREMENT - настоящий, если id удалён - счётчик идёт дальше	
- экранирование строк(никаких addslashes и прочего) только через метод $db-> escapeString($string);

$db = new SQLite3('test.db'); - создание экземпляра класса SQLine3? test.db - имя базы данных.
	если такой файл есть - устанавливается с ним соединение
	unset($db) - закрыть соединение и удалить файл базы данных
если нужно  перейти без удаления файла на другую базу Ж
$db->close();
$db->open(<имя другой db>); это аналог USE в мониторе Mysql
!!!$result = $db->exec($sql) - безответый SQL запрос посылается EXECом ELECT, CREATE, DELETE (возвращает true или false)
$db->changes(); - количество изменнных(удалённых) записей  
$db->LastErorCode(); - код ошибки в SQL запросе
$db->LastErorMsg();- описание ошибки в SQL запросе

	Подготовленные запросы в SQLite
$sql = 'SELECT name FROM user WHERE id = :id'; - place holder поименованный :id и индексированный ?
$stmt = $db->prepare($sql);// возвращает объект Statement (стэйтмент)
$stmt->bindParam(':id', $id); // "привязывает" параметр к передаваемой переменной(если поименованный плейсхолдер - строкой':id', если неименованный - порядковой цифрой)
$result = $stmt-execute();// возвращается объект или false 
$stmt->close();//если стэйтмент больше не нужен// если ещё нужно ео использовать - reset();
$row = $result->fetchArray;// перебрать, это если запрос SELECT на выборку с БД

ОБРАБОТКА ИСКЛЮЧЕНИЙ В SQLite:
	В методе основного класса : 
		function deleteNews($id){
				try{
				$sql = "DELETE FROM msgs WHERE id = $id";
				$res = $this->_db->exec($sql);
				if (!$res){
					throw new Exception($this->_db->lastErrorMsg());
				}
				return true;
				}
				
				catch(Exception $e){
					// $e->getMessage(); // можно послать себе письмо с ошибкой
					return false;// остальным вывалим false
				}
			}
	в хендлере обработчике удаления (так как приходит false) пишем
		$id = $news->clearInt($_GET['del']);
			if ($id){
				if (!$news->deleteNews($id)){
					$errMsg = "Произошла ошибка удаления";
				}
				else{
				header('Location: news.php');
				exit;
				}
			}






Шпора по ООП:
$name = new <имя>(); - new - создание объекта(сущности, экземпляра класса)
__CLASS__ - псевдоконстанта, размещённая в методе, вернёт вернёт "Класс"
__METHOD__  псевдоконстанта, размещённая в методе, вернёт "Класс:метод"
function __construct (){} - конструктор (функция), который запускается при создании объекта класса
function __dectruct(){} - деструктор, который запускается при удалении объекта
$newobj = clone $obj; - клонирование объекта (конструктор не запускается)
	если необходимо при клонировании запускать конструктор - в класс добавляем метод function __clone(){} 
	!!! создавая класс обязательно описывать конструктор, деструктор и clone.
	
	
Переопределение методов
	parent:: <родительский метод> - размещённый в методе наследника
		добавить ещё один аргумент в __construct
		function __construct ($a, $b, $c, $d){
		parent:: __construct($a, $b, $c);
		this-><name> = $d;
		}
	
Модификаторы доступа к свойствам и методам класса :
	- public(видимость глобальная, из наследника и из родителя)
	- protected(видимость из наследника и из родителя)
	- private (видимость из родителя).
	_<свойство или метод> - у защищённого метода (свойства) имя начинается с подчёркивания

Обработка исключений (ошибки, которые не должны приводить к остановке выполнения кода) :
	- try {
	 throw new Exception("сообщение") - проброс исключения в catch, между ними код игнорится;
	<?
		try {
		$a = 1;
		$b = 0;	
			if ($b ==0){
				throw new Exception ("на ноль делить нельзя!<br>");
			}
			$c = $a/$b;
		}
		catch (Exception $e){
			echo "Ошибка : ".$e->GetMessage()."<br>";
			echo "В строке : ".$e->GetLine()."<br>";
			echo "В файле : ".$e->GetFile()."<br>";
		}
		echo "А код продолжается";
	?> 
		Try/catch обязательно размещается в классе внутри метода
		Блоков Try может быть несколько, и все они отлавливаются в одном catch. В Try может быть несколько if, как только срабатывает первый, остальные не перебираются
		Класс Exception можно наследовать, но обязательно перегружать его конструктор (совместимость с будущими PHP).
		function __construct($<что приходит>){
			parent:: __construct($<что приходит>);
		}
		
Перебор свойств объекта ("снаружи" видит только свойства public):
	$human1 = new Human("Иванов Иван Иваныч", 55);
	foreach ($human1 as $a=>$b){
		echo $a."  :  ".$b."<br>";}

Константы класса 
	const <имя константы> = <значение константы> - задать константу внутри класса
	self::<имя константы> - вызов константы класса в методе
	$<имя экземпляра класса>::<имя константы> - обращение к константе класса из-вне

Абстрактные классы и методы (служат для контроля исполнения архитектора и прогр.)	
	abstract class <имя класса>{} -	Абстрактный класс - класс от которого нельзя создать обьект напрямую, его можно только наследовать(может не иметь абстрактных методов)
	abstract function() - абстрактный метод (бывает только в абстрактном классе), без переопределения предка наследником - не работает

Интерфейс (Контракт) - абстрактный класс, имющий только абстрактные методы. Один интерфейс - много реализаций
	interface <имя>{
		function <имя>(); // метод
	}
	class <имя> implements <имя интерфейса>, <имя интерфейса>, ... (наследуемые интерфейсы не должны содержать одноименные методы)  

Финальные классы и методы - невозможно перегрузить метод(применяется, например если описание метода ещё не готово) и наследовать класс
final function <имя>();  

в методе класса $this - это указатель на объект класса как массив, свойства которого можно перебрать 
		В классе делаешь метод :  
		function showSV(){
		  foreach($this as $n=>$p){
		   echo $n." : ".$p."<br>";
		 }
		 }

		Вызываешь его из глобалки для какого нить объекта этого класса : 
		$user1->showSV();
		и получаешь :
		name : Иван
		lastname : Иванов
		password : 12345

		Статические свойства и методы - видны с глобаной области видимости даже когда код отработал :
static <имя свойства> - создание стат. свойства
self:: <$имя свойства> - вызов статического свойства в методе
<имя класса>::<$имя статического свойства> - вызов с глобальной зоны видимости 
static <имя метода> - создание стат. метода, видимого из глобальной зоны (когда не было пространства имён до 5.3. - обёртка одинаковых методов )
static::<$имя метода>() - вызов статического метода в другом статическом методе
	можно обращаться не создавая экземпляр класса
	
		Позднее статическое связывание необходимо при НАСЛЕДОВАНИИ статических методов (т.е. ст. методы реализовываются на этапе компиляции)
	static::<$имя метода>() - вызов при наследовании статического метода в другом методе
		class A{
			static function A1(){
				echo "A1";
			}
			static function A2(){
				static::A1();
			}
		}
		class B extends A{
			static function A1(){
				echo "В";
			}
		}

		B::A2();
		
Наследование проверка на предка класс или интерфейса(два варианта):
	if (is_a($SuperUser1, User)){// преверяется наследование, т.е. есть ли в наследком у User $SuperUser1
		echo "Всё окей!";}
	if (SuperUser1 instanceOf User){// преверяется наследование, т.е. есть ли в наследком у User $SuperUser1
		echo "Всё окей!";}
	
Функция автоподключения класса (в папrе class каждый класс в отдельном файле)
	function __autoload($name){
		include "/class/".$name.".class.php";
	
Сеттеры и геттеры (обращение к свойству которого нет или оно приватное) : без них можно получить доступ к свойствам которых нет в классе(полям), ести прописаны set и get, то обращение идёт уже только через них
(__set срабатывает когда вызывается свойство класса которого там нет)
	Свойство - интерфейс доступа к полям
	class c {
		public $arr = array();
		function __set($n, $v){// где $n - имя поля (свойства) а $v его значение
			$this->arr[$n] = $v; 
		}	
		function __get($n){// где $n - имя поля (свойства)
			return $this->arr[$n];
		}
		function showArr(){
			echo $this->arr;
		}
	}

Доступ к невидимым или приватным методам (обращение к методу которого нет)
	function _call (<имя метода>, <массив аргументов>){}
		function __call($n, $v){
			echo "Новый метод ".$n;
			foreach($v as $c){
				echo " передал аргументы ".$c;	
			}
		}
	static function __callStatic (<имя метода>, <массив аргументов>) {// имя СТАТИЧЕСКОГО метода РЕГИСТРОЗАВИСИМО!

При приведении объекта к строке (например echo <имя объекта>) ищется маг. метод
	__toString
		function __toString(){
			return "Hello!";
		}	
Обращение к объекту как к функции echo $x(5) - автоматически срабатывает магический метод 
	__invoke
		function __invoke($val){
			echo $val*$val;
		}
		echo $x(5);
		
Указатель (контроль) типа Type-Hint переменной корая приходит в функцию (метод) 
	function foo (array $x) - должен придти только массив
	function foo (<имя класса> <имя объекта>) - должен придти только объект
	function foo (collable <имя>) - должен придти только вызываемый тип
	function foo (<имя объекта> <имя метода>) - должен придти метод определённого объекта
	
Сериализация объектов (исп. напр. в сессиях)??????????????????????????????
__sleep(){
	return array("login", "password");}// login и password это те свойства которые нужно сохранить	
Ансериалайз (при нём конструктор не вызывается, поэтому нужно быть)

Типажи (trait)(Php 5.4.) - позволяют произвести множественное наследование, а также перегружать в наследниках private методы родителя!!! 
	в классах такого делать нельзя(можно назвать так же, но описывать нужно заново), можно использовать при наследовании трейтов методы с одинаковыми
	именами 
		trait Hello{
			function hello(){
				return "Hello";}
		}
		trait User {
			function user($name){
				return $name;}
		}
		class Welcome {
			use Hello, User; // use - наследование
		}
	
!!!!!!!!!!Разименовывание объекта (если невозможно сделать метод статическим!!!служит для того чтобы налету создавать экземпляр класса, "дёргать его метод и удалять его")
		class A{
			function foo (){
				echo __CLASS__;
			}
		}
		class B{
			function foo (){
				echo __CLASS__;
			}
		}	

			function deref($name){
				switch ($name){
				case "A" : return new A;break; 
				case "B" : return new B;break; 
				}
			}
			deref("A")->foo();
			deref("B")->foo();

Цепочки 


			
Работа с Git

Чтобы git  видел русское название файлов необходимо ввести параметр quotepath в секцию [core], установив его в false. 

$ ssh-keygen -t rsa -b 4096 -C "motobycom@tut.by" - сгенерировать Ssh ключ

quotepath = false 
git status - просмотр состояния
gitk - графическое отображение коммитов
- просмотр git log с переносом строк :набрать  - и потом "shift s"
- git diff --color-words - показывает изменения не отдельной строкой, а в коде

- git commit -am (Добавляет все изменения в буфер и закомитить из все за раз) РАБОТАТЬ С ОСТОРОЖНОСТЬЮ НЕ ДОБАВЛЯЕТ УДАЛЁННЫЕ И НЕ ОТСЛЕЖИВАЕМЫЕ!
- ctrl+l - очистить историю
- git checkout <file> - вернуть непро staged (add) изменение из репозитория в рабочую папку
- git reset HEAD <file> - вернуть staged изменение, сделав его "красным"
- git commit --amend -m "комментарий" перекоммитить закомиченое изменение
- git checkout master - возврат головки на самый свежий коммит
- git revert <SHA коммита, который нужно отменить> - отмена всех изменений коммита
- git reset --soft или --mixed или --hard  <SHA коммита, на который нужно перейти>
- git clean -n - показывает неотслеживаемые файлы которые собирается удалить
- git clean -f - удаляет их

git config --global core.excludesfile C:\Users\Harnet\.git\.gitignore_global - настройки файла глобального игнорирования

git log --oneline  - показывает в одну строчку все логи
git log --since="год-месяц-день" - коммиты с определённой даты
git log --until="год-месяц-день" - коммиты до определённой даты
git log --until="3 days ago" - коммиты до определённой даты
!!!git log -p  - показывает что коммиты делали

git log --stat --summary --oneline -p <название файла> - какие изменения были сделаны в файле 

git log --graph - показывает ветки
git diff <sha> - показывает разницу между раб. дир и коммитом
git diff <sha> <file> - показывает разницу В ОТДЕЛЬНОМ ФАЙЛЕ между раб. дир и коммитом
git diff <sha>..<sha> - показывает разницу между двумя коммитами
gif diff --stat --summary <sha> - показывает список всех изменений во всех файлах

git branch - список всех бранчей
cat .git/HEAD - в каком бранче находится головка
ls -la .git/refs/heads -показывает все бранчи в папке
git branch <имя бранча> - создание нового бранча
git checkout <имя бранча> - переключает на выбранный бранч
git checkout -b <имя бранча> - создайт и переключает на бранч
git log --graph --oneline --decorate --all - показывает бранчи и изменения в них
git diff <имя бранча>..<имя бранча> - сравнение бранчей
git diff <имя бранча>..<имя бранча>^ - сравнение бранча и предков другого бранча
git branch --merged - показывает в каких бранчах есть все коммиты которые есть в другом
git branch -m <имя бранча><новое имя бранча> - переименнование бранча
git branch -d <имя бранча> - удаление бранча

echo $PS1 - показывает настройки "приглашения"(сообщения при вводе комманд)

Быстрое слияние возможно тогда, когда в мастере не было коммитов после создания бранча

git merge <бранч> - !!!стоЯть на мастере - БЫСТРОЕ СЛИЯНИЕ объединяет (накатывает изменения на мастер) бранч к мастером
git merge --no--ff <бранч-донор> - быстрое слияние с созданием коммита
git merge --abort - отмена слияния при конфликте слияния

git stash save "Сообщение" - положить изменения, которые мешают переключиться на бранчи в копилку
git stashe list - просмотр "копилки"
git stash show -p <stash@{0}> - показ изменений в копилке
git stash pop <stash@{0}> - отправят изменения из выбранной копилки в раб. дир и удаляет из копилки
git stash apply <stash@{0}> - отправят изменения из выбранной копилки в раб. дир и удаляет из копилки
git stash drop <stash@{0}> - удаление из копилки
gir stash clear - очищает копилку целиком

Удалённые репозитории
git remote - список всех удалённых репозиториев
git remote add <имя сервера> <url аккаунта на github> - создание сетевого репозитория
git remote -v - инфа по репозиторию
git remote rm <имя сетевого репозитория> - удалить репозиторий
git push -u <имя сетевого репозитория> - начать работу с удалённым репозиторием и команда отслеживать изненения в удалённом реп.
git push origin <имя бранча> - отправка ветки в удалённый репозитория, которая не будет отслеживаться
git branch --set-upstrem non_tracking origin/<имя неотслеживаемой ветки> - сделать ветку отслеживаемой 

git remote -r - покажет удалённые репозитории
git remote -a - покажет локальные и удалённые репозитории
git clone <url удалённого репозитория> - клонирование сетевого репозитория и именем как в том проекте и с бранчем по умолчанию
git clone <url удалённого репозитория> <имя> - клонирование сетевого репозитория с указанным именем
git clone -b <url удалённого репозитория> <имя> - клонирование определённого бранча из репозитория


git branch -r - ветки на удалённом репозитории
git branch -a - все бранчи, вкл удалённые
git fetch - актуализирует локальный репозиторий origin/master с удалённым репозиторием
git merge origin/master - слияние origin/master(который мы fetch) с master
git pull - переносит изменения с origin/master в master
git branch <название бранча> <origin/название удалённого бранча> - добавить в свои бранчи "удалённый" отслеживаемый бранч другого человека
git branch -b <название бранча> <origin/название удалённого бранча> - добавить в свои бранчи "удалённый" отслеживаемый бранч другого человека
git branch origin :<имя бранча> - удаление сетевого бранча
git push origin :<имя бранча> - удаление сетевого бранча
git push origin --delete <имя бранча> - удаление сетевого бранча (способ 2)
$ git remote update origin --prune - очищает несуществующие в сетевом репозитарии ветки, которые видны при "branch -r"

git config --global alias.st "status" - назначить синоним(алиас) для стандартной команды GIT
   Стандартные алиасы :
git config --global alias.co "checkout"
git config --global alias.ci "commit"
git config --global alias.br "branch"
git config --global alias.df "diff"
git config --global alias.dfs "diff --staged"
git config --global alias.logg "log --graph --decorate --all --abbrev-commit --oneline"






